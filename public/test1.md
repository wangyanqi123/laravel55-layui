### 1.魔术方法
__autoload () 类文件自动加载函数
	__construct () 构造函数，PHP 将在对象创建时调用这个方法
	__destruct ()  析构函数，PHP 将在对象被销毁前（即从内存中清除前）调用这个方法
	__call () 当所调用的成员方法不存在（或者没有权限）该类时调用，用于对错误后做一些操作或者提示信息
	__clone () 该函数在对象克隆时自动调用，其作用是对克隆的副本做一些初始化操作
	__get () 当所对象所调用的成员属性未声明或者级别为 private 或者 protected 等时，我们可以在这个函数里进行自己的一些操作
	__set () 当所对未声明或者级别为 private 或者 protected 等进行赋值时调用此函数，我们可以在这个函数里进行自己的一些操作
	__isset () 当对一个未声明或者访问级别受限的成员属性调用 isset 函数时调用此函数，共用户做一些操作
	__unset () 当对一个未声明或者访问级别受限的成员属性调用 unset 函数时调用此函数，共用户做一些操作
	__toString () 函数 该函数在将对象引用作为字符串操作时自动调用，返回一个字符串
	__sleep () 函数 该函数是在序列化时自动调用的，序列化这里可以理解成将信息写如文件中更长久保存
	__wakeup () 函数 该魔术方法在反序列化的时候自动调用，为反序列化生成的对象做一些初始化操作
	invoke () 函数，当尝试以调用函数的方式调用一个对象时，invoke 方法会被自动调用。
	_callStatic () 函数，它的工作方式类似于 call () 魔术方法，callStatic () 是为了处理静态方法调用。
<br/>
### 2.常见状态代码、状态描述
	200 OK：客户端请求成功。
	400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
	401 Unauthorized：请求未经授权，这个状态代码必须和 WWW­Authenticate 报头域一起使用。
	403 Forbidden：服务器收到请求，但是拒绝提供服务。
	404 Not Found：请求资源不存在，举个例子：输入了错误的 URL。 500 Internal Server Error：服务器发生不可预期的错误。
	503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1  200 OK（CRLF）。
<br/>
### 3.PHP5 跟 php7 的区别
	变量存储字节减小，减少内存占用，提升变量操作速度
	性能提升：PHP7 比 PHP5.0 性能提升了两倍。
	全面一致的 64 位支持。
	以前的许多致命错误，现在改成 [抛出异常]。
	PHP 7.0 比 PHP5.0 移除了一些老的不在支持的 SAPI（[服务器端] 应用编程端口）和扩展。
	.PHP 7.0 比 PHP5.0 新增了空接合操作符。
	PHP 7.0 比 PHP5.0 新增加了结合比较运算符。
	PHP 7.0 比 PHP5.0 新增加了函数的返回类型声明。
	PHP 7.0 比 PHP5.0 新增加了标量类型声明。
	PHP 7.0 比 PHP5.0 新增加匿名类。
<br/>
### 4.多进程同时读写一个文件  [详细]
	PHP 是支持进程的而不支持多线程（这个先搞清楚了），如果是对于文件操作，其实你只需要给文件加锁就能解决，不需要其它操作，PHP 的 flock 已经帮你搞定了。
	用 flock 在写文件前先锁上，等写完后解锁，这样就实现了多线程同时读写一个文件避免冲突。
[详细]: http://learnku.com/articles/28772 "详细"
<br/>
###5.设计模式
	抽象工厂模式：在不指定具体类的情况下创建一系列相关或依赖对象。 通常创建的类都实现相同的接口。 抽象工厂的客户并不关心这些对象是如何创建的，它只是知道它们是如何一起运行的。
    建造者模式：建造者是创建一个复杂对象的一部分接口。有时候，如果建造者对他所创建的东西拥有较好的知识储备，这个接口就可能成为一个有默认方法的抽象类（又称为适配器）。如果对象有复杂的继承树，那么对于建造者来说，有一个复杂继承树也是符合逻辑的。注意：建造者通常有一个「流式接口」，例如 PHPUnit 模拟生成器。
    工厂方法模式：对比简单工厂模式的优点是，您可以将其子类用不同的方法来创建一个对象。举一个简单的例子，这个抽象类可能只是一个接口。这种模式是「真正」的设计模式， 因为他实现了 S.O.L.I.D 原则中「D」的 「依赖倒置」。这意味着工厂方法模式取决于抽象类，而不是具体的类。 这是与简单工厂模式和静态工厂模式相比的优势。
    多例模式：多例模式被公认为是 反面模式，获得更好的可测试性和可维护性，使用『依赖注入模式』。 多例模式是指存在一个类有多个相同实例，而且该实例都是该类本身。这个类叫做多例类。 多例模式的特点是：多例类可以有多个实例。多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。多例模式实际上就是单例模式的推广。
    对象池模式：对象池模式是一种提前准备了一组已经初始化了的对象『池』而不是按需创建或者销毁的创建型设计模式。对象池的客户端会向对象池中请求一个对象，然后使用这个返回的对象执行相关操作。当客户端使用完毕，它将把这个特定类型的工厂对象返回给对象池，而不是销毁掉这个对象。在初始化实例成本高，实例化率高，可用实例不足的情况下，对象池可以极大地提升性能。在创建对象（尤其是通过网络）时间花销不确定的情况下，通过对象池在可期时间内就可以获得所需的对象。无论如何，对象池模式在需要耗时创建对象方面，例如创建数据库连接，套接字连接，线程和大型图形对象（比方字体或位图等），使用起来都是大有裨益的。在某些情况下，简单的对象池（无外部资源，只占内存）可能效率不高，甚至会有损性能。
    原型模式：相比正常创建一个对象 (new Foo () )，首先创建一个原型，然后克隆它会更节省开销。
    简单工厂模式：简单工厂模式是一个精简版的工厂模式。它与静态工厂模式最大的区别是它不是『静态』的。因为非静态，所以你可以拥有多个不同参数的工厂，你可以为其创建子类。甚至可以模拟（Mock）他，这对编写可测试的代码来讲至关重要。
    单例模式：单例模式被公认为是 反面模式，为了获得更好的可测试性和可维护性，请使用『依赖注入模式』。主要为了在应用程序调用的时候，只能获得一个对象实例。主要包括：数据库的连接，日志的使用等。
    静态工厂模式：与抽象工厂模式类似，此模式用于创建一系列相关或相互依赖的对象。 『静态工厂模式』与『抽象工厂模式』的区别在于，只使用一个静态方法来创建所有类型对象， 此方法通常被命名为 factory 或 build。
<br/>
### 6.laravel 的生命周期
	加载项目依赖，注册加载 composer 自动生成的 class loader，也就是加载初始化第三方依赖。
	创建应用实例，生成容器 Container，并向容器注册核心组件，是从 bootstrap/app.php 脚本获取 Laravel 应用实例，并且绑定内核服务容器，它是 HTTP 请求的运行环境的不同，将请求发送至相应的内核： HTTP 内核 或 Console 内核。
	接收请求并响应，请求被发送到 HTTP 内核或 Console 内核，这取决于进入应用的请求类型。HTTP 内核继承自 Illuminate\Foundation\Http\Kernel 类，该类定义了一个 bootstrappers 数组，这个数组中的类在请求被执行前运行，这些 bootstrappers 配置了错误处理、日志、检测应用环境以及其它在请求被处理前需要执行的任务。HTTP 内核还定义了一系列所有请求在处理前需要经过的 HTTP 中间件，这些中间件处理 HTTP 会话的读写、判断应用是否处于维护模式、验证 CSRF 令牌等等。
	发送请求，在 Laravel 基础的服务启动之后，把请求传递给路由了。路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。传递给路由是通过 Pipeline（管道）来传递的，在传递给路由之前所有请求都要经过 app\Http\Kernel.php 中的 $middleware 数组，也就是中间件，默认只有一个全局中间件，用来检测你的网站是否暂时关闭。所有请求都要经过，你也可以添加自己的全局中间件。然后遍历所有注册的路由，找到最先符合的第一个路由，经过它的路由中间件，进入到控制器或者闭包函数，执行你的具体逻辑代码，把那些不符合或者恶意的的请求已被 Laravel 隔离在外。
<br/>
### 7.多态性
	子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法。后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。
<br/>
### 8.使用 nginx 与 apache 相比
	最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程；nginx 是异步的，多个连接（万级别）可以对应一个进程 （nginx 处理请求是异步非阻塞的，而 apache 则是阻塞型的）
	在高并发下 nginx 能保持低资源低消耗高性能。静态文件。
	apache 相对于 nginx 的优点： rewrite ，比 nginx 的 rewrite 强大 模块超多，基本想到的都可以找到 少 bug 。
<br/>
### 9.MySQL 索引的创建原则
	索引并不是越多越好，要根据查询有针对性的创建，考虑在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根据 EXPLAIN 来查看是否用了索引还是全表扫描
	应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描
	使用多列索引必须满足最左匹配，注意顺序和查询条件保持一致，同时删除不必要的单列索引
	OR 关键字的两个字段必须都是用了索引，该查询才会使用索引.
	LIKE 关键字匹配 '%' 开头的字符串，不会使用索引.
	值分布很稀少的字段不适合建索引，例如 "性别" 这种只有两三个值的字段
	字符字段只建前缀索引，最好不要做主键
	不用外键，由程序保证约束
	尽量不用 UNIQUE，由程序保证约束；
<br/>
### 10.选择合适的索引列
	1）查询频繁的列，在 where，group by，order by，on 从句中出现的列
	2）where 条件中 <，<=，=，>，>=，between，in，以及 like 字符串 + 通配符（%）出现的列
	3）长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好
	4）离散度大（不同的值多）的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count 越大，离散程度越高
<br/>
### 11.Redis、Memecached 这两者有什么区别？
	Redis 支持更加丰富的数据存储类型，String、Hash、List、Set 和 Sorted Set。Memcached 仅支持简单的 key-value 结构。
	Memcached key-value存储比 Redis 采用 hash 结构来做 key-value 存储的内存利用率更高。
	Redis 提供了事务的功能，可以保证一系列命令的原子性
	Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中
	Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。
<br/>
### 12、MyISAM和 InnoDB 的基本区别？索引结构如何实现？
	A、MyISAM类型不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，适合用于频繁查询的应用；
	B、InnoDB类型支持事务，行锁，有崩溃恢复能力，读写速度比MyISAM慢，适合于插入和更新操作比较多的应用，空间占用大，不支持全文索引等。
<br/>
### 13、什么是 CSRF 攻击 ？XSS 攻击？如何防范？
    CSRF，跨站请求伪造，攻击方伪装用户身份发送请求从而窃取信息或者破坏系统。
    讲述基本原理：用户访问A网站登陆并生成了cookie，再访问B网站，如果A网站存在CSRF漏洞，此时B网站给A网站的请求（此时相当于是用户访问），A网站会认为是用户发的请求，从而B网站就成功伪装了你的身份，因此叫跨站脚本攻击。
    CSRF防范：
	A、合理规范api请求方式，GET，POST
	B、对POST请求加token令牌验证，生成一个随机码并存入session，表单中带上这个随机码，提交的时候服务端进行验证随机码是否相同。
	XSS，跨站脚本攻击。
	防范：不相信任何输入，过滤输入。
<br/>
###14.生命周期
	1.入口文件：
	Laravel框架所有请求入口统一进入/public/index.php文件，请求通过Ngxin/Apache指向该文件。
	index.php文件是加载其他文件入口，本身代码不多。index.php文件载入通过Composer生产的自动加载配置，然后从bootstrap/app.php获取应用实例，创建服务容器。
	2.Http/Console内核
	接上面，请求被发送到HTTP内核或Console内核，取决于应用请求类型（会在下篇文章说明）。这两个内核为所有请求必须经过的中央处理器，
	下面介绍App\Http\Kernel的HTTP内核：
	HTTP内核 继承自Illuminate\Foundation\Http\Kernel类，该类定义了一个bootstrappers数组，该数组中的类在请求被执行前运行，bootstrappers配置了错误处理、日志、检测应用环境、其他在请求被处理前需要处理的任务。
	HTTP内核还定义请求处理前需要经过HTTP中间件，该中间件处理HTTP会话的读写、判断应用是否处于维护模式，验证CSRF令牌（防止CSRF攻击）等。
	HTTP内核标签方法handle：获取一个Request，返回一个Response，输入HTTP请求，返回HTTP响应。
	3.服务提供者
	内核启动会为应用载入服务提供者，服务提供者都被配置在config/app.php配置文件的providers数组中。服务提供者被注册后，boot方法被调用。
	服务提供者负责启动框架的所有组件，如数据库、队列、验证器、路由组件等。因他们启动并配置框架提供的所有特性，服务提供者是整个Laravel启动过程中最重要部分。
	「延迟」提供器：即providers数组中较多服务都是提供的实际服务需要才会加载。
	4. 分发请求
	一旦应用被启动且所有服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。